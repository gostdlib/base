// Package context is a drop in replacement for the standard library's context package.
// It provides additional functionality to the context package, such as attaching various clients
// to the context when calling Background().  This should be called after init.Service() to ensure
// that the clients are initialized. All clients that are attached to the context should return a
// a value that is safe to call methods on.
package context

import (
	"log/slog"
	"time"

	"github.com/gostdlib/base/concurrency/background"
	"github.com/gostdlib/base/concurrency/worker"
	"github.com/gostdlib/base/context"
	"github.com/gostdlib/base/errors"
	"github.com/gostdlib/base/telemetry/otel/trace/span"
	"go.opentelemetry.io/otel/metric"
)

// Background returns a non-nil, empty [Context]. It is never canceled, and has no deadline.
// It is typically used by the main function, initialization, and tests, and as the top-level
// Context for incoming requests. This differs from the Background() function in the context package
// in that it attaches various clients to the context. This currently attaches:
//
// - log.Default(), a *slog.Logger.
// - metrics.Default(), a metric.MeterProvider.
// - worker.Default(), a *worker.Pool.
// - background.Default(), a *background.Tasks.
//
// These can be accessed using the Audit()/Log()/Metrics functions.
func Background() Context {
    // insert here anything you want attached to your Context object.
	return context.Background()
}

// Attach attaches the logger and metrics clients to the context.
// This is generally not called directly, but is used by Background() and
// things like RPC packages that need to attach these to an already existing context.
func Attach(ctx Context) Context {
    ctx = context.Attach(ctx)

	/* Add your own clients here if you need to attach at some other entry point not supported. */
	/* DO NOT USE THIS ON A CONTEXT GENERATED BY Background() */
	return ctx
}

// Logger is a wrapper around an *slog.Logger that prevents loss of Context logging attributes.
type Logger = context.Logger

// Log returns a Logger with the *slog.Logger that is attached to the context. If no logger is attached,
// it returns Logger wrapping log.Default().
func Log(ctx Context) Logger {
    return context.Log(ctx)
}

// Meter returns a metric.Meter scoped to the package that calls context.Meter(). If you need to have a
// sub-namespace for a specific package, you should use the MeterProvider() function to get the meter provider.
// If no meter is attached to the context it returns a meter from metrics.Default(). This may be a noop Meter.
func Meter(ctx Context, opts ...metric.MeterOption) metric.Meter {
    const stackFrame = 3
    return context.MeterWithStackFrame(ctx, stackFrame, opts...)
}

// MeterWithStackFrame returns a metric.Meter scoped to the stack frame number provided by "sf".
// This is for uses by packages that use this underneath so they can get the write stack frame.
// Generally, you should be using Meter().
func MeterWithStackFrame(ctx Context, sf uint, opts ...metric.MeterOption) metric.Meter {
    // The sf passed in is relative to this function, so we need to add 1 to get the caller of this function.
    return context.MeterWithStackFrame(ctx, sf+1, opts...)
}

// MeterProvider returns a metric.MeterProvider attached to the context. If no meter provider is attached,
// it returns metrics.Default(). This may be a noop provider.
func MeterProvider(ctx Context) metric.MeterProvider {
    return context.MeterProvider(ctx)
}

// NewSpan creates a new child span object from the span stored in Context. If that Span is
// a noOp, the child span will be a noop too. If you pass a nil Context, this will return
// the background Context with a noop span. If an option is passed that is not valid,
// it is ignored and an error is logged. The span is created with a span kind of internal,
// unless another span kind is passed using WithSpanStartOption(WithSpanKind([kind])).
// This starts the span.
func NewSpan(ctx Context, options ...span.Option) (Context, span.Span) {
	return span.New(ctx, options...)
}

// Span returns the current span from the context. If no span is attached, it returns a noop span.
func Span(ctx Context) span.Span {
	return span.Get(ctx)
}

// Pool returns the worker pool attached to the context. If no pool is attached, it returns worker.Default().
func Pool(ctx Context) *worker.Pool {
    return context.Pool(ctx)
}

// Tasks returns a background.Tasks attached to the context. If not tasks are attached,
// it returns background.Default().
func Tasks(ctx Context) *background.Tasks {
    return context.Tasks(ctx)
}

// AddAttrs adds slog.Attr attributes to the context. These attributes can be used by logging,
// tracing or errors packages to add additional context to logs, traces or errors. Duplicate attr
// keys are allowed, but upper layer packages will apply the last value for a given key.
func AddAttrs(ctx context.Context, attrs ...slog.Attr) context.Context {
	return context.AddAttrs(ctx, attrs...)
}

// Attrs returns the slog.Attr attributes attached to the context. If no attributes are attached, it returns nil.
func Attrs(ctx context.Context) []slog.Attr {
    return context.Attrs(ctx)
}

// SetShouldTrace attaches a boolean value to the context to indicate if the request should be traced.
// This is not usually used by a service, but by the middleware to determine if the request should
// be traced. This only works if done before the trace is started.
func SetShouldTrace(ctx context.Context, b bool) context.Context {
	return context.SetShouldTrace(ctx, b)
}

// ShouldTrace returns true if the request has had SetShouldTrace called on it.
func ShouldTrace(ctx context.Context) bool {
	return context.ShouldTrace(ctx)
}

// EOptions returns the error options attached to the context. If no options are attached, it returns nil.
// This allows for setting per call error options. These will override local options if the same options are set.
// An example of this is writing a traceback to errors on a specific call or all calls.
func EOptions(ctx context.Context) []errors.EOption {
	return context.EOptions(ctx)
}

// SetEOptions attaches error options to the context. This allows for setting per call error options.
// These will override local options if the same options are set. An example of this is writing a traceback
// to errors on a specific call or all calls.
func SetEOptions(ctx context.Context, options ...errors.EOption) context.Context {
	return context.SetEOptions(ctx, options...)
}

// Everything below here is a wrapper around the stdlib context package.
// We do this to prevent having to import the stdlib ctonext package in every file that needs it.

var (
	// Canceled is the error returned by [Context.Err] when the context is canceled.
	Canceled = context.Canceled
	// DeadlineExceeded is the error returned by [Context.Err] when the context's deadline passes.
	DeadlineExceeded = context.DeadlineExceeded
)

// AfterFunc arranges to call f in its own goroutine after ctx is done
// (canceled or timed out).
// If ctx is already done, AfterFunc calls f immediately in its own goroutine.
//
// Multiple calls to AfterFunc on a context operate independently;
// one does not replace another.
//
// Calling the returned stop function stops the association of ctx with f.
// It returns true if the call stopped f from being run.
// If stop returns false,
// either the context is done and f has been started in its own goroutine;
// or f was already stopped.
// The stop function does not wait for f to complete before returning.
// If the caller needs to know whether f is completed,
// it must coordinate with f explicitly.
//
// If ctx has a "AfterFunc(func()) func() bool" method,
// AfterFunc will use it to schedule the call.
func AfterFunc(ctx Context, f func()) (stop func() bool) {
	return context.AfterFunc(ctx, f)
}

// Cause returns a non-nil error explaining why c was canceled.
// The first cancellation of c or one of its parents sets the cause.
// If that cancellation happened via a call to CancelCauseFunc(err),
// then [Cause] returns err.
// Otherwise Cause(c) returns the same value as c.Err().
// Cause returns nil if c has not been canceled yet.
func Cause(c Context) error {
	return context.Cause(c)
}

// WithCancel returns a copy of parent with a new Done channel. The returned
// context's Done channel is closed when the returned cancel function is called
// or when the parent context's Done channel is closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this [Context] complete.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	return context.WithCancel(parent)
}

// WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
// Calling cancel with a non-nil error (the "cause") records that error in ctx;
// it can then be retrieved using Cause(ctx).
// Calling cancel with nil sets the cause to Canceled.
//
// Example use:
//
//	ctx, cancel := context.WithCancelCause(parent)
//	cancel(myError)
//	ctx.Err() // returns context.Canceled
//	context.Cause(ctx) // returns myError
func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc) {
	return context.WithCancelCause(parent)
}

// WithDeadline returns a copy of the parent context with the deadline adjusted
// to be no later than d. If the parent's deadline is already earlier than d,
// WithDeadline(parent, d) is semantically equivalent to parent. The returned
// [Context.Done] channel is closed when the deadline expires, when the returned
// cancel function is called, or when the parent context's Done channel is
// closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this [Context] complete.
func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
	return context.WithDeadline(parent, d)
}

// WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
// returned Context when the deadline is exceeded. The returned [CancelFunc] does
// not set the cause.
func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc) {
	return context.WithDeadlineCause(parent, d, cause)
}

// WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this [Context] complete:
//
//	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
//		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
//		defer cancel()  // releases resources if slowOperation completes before timeout elapses
//		return slowOperation(ctx)
//	}
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return context.WithTimeout(parent, timeout)
}

// WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
// returned Context when the timeout expires. The returned [CancelFunc] does
// not set the cause.
func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc) {
	return context.WithTimeoutCause(parent, timeout, cause)
}

// A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.
// This cause can be retrieved by calling [Cause] on the canceled Context or on
// any of its derived Contexts.
//
// If the context has already been canceled, CancelCauseFunc does not set the cause.
// For example, if childContext is derived from parentContext:
//   - if parentContext is canceled with cause1 before childContext is canceled with cause2,
//     then Cause(parentContext) == Cause(childContext) == cause1
//   - if childContext is canceled with cause2 before parentContext is canceled with cause1,
//     then Cause(parentContext) == cause1 and Cause(childContext) == cause2
type CancelCauseFunc = context.CancelCauseFunc

// A CancelFunc tells an operation to abandon its work.
// A CancelFunc does not wait for the work to stop.
// A CancelFunc may be called by multiple goroutines simultaneously.
// After the first call, subsequent calls to a CancelFunc do nothing.
type CancelFunc = context.CancelFunc

// A Context carries a deadline, a cancellation signal, and other values across
// API boundaries.
//
// Context's methods may be called by multiple goroutines simultaneously.
type Context = context.Context

// TODO returns a non-nil, empty [Context]. Code should use context.TODO when
// it's unclear which Context to use or it is not yet available (because the
// surrounding function has not yet been extended to accept a Context
// parameter).
func TODO() Context {
	return context.TODO()
}

// WithValue returns a copy of parent in which the value associated with key is
// val.
//
// Use context Values only for request-scoped data that transits processes and
// APIs, not for passing optional parameters to functions.
//
// The provided key must be comparable and should not be of type
// string or any other built-in type to avoid collisions between
// packages using context. Users of WithValue should define their own
// types for keys. To avoid allocating when assigning to an
// interface{}, context keys often have concrete type
// struct{}. Alternatively, exported context
func WithValue(parent Context, key, val interface{}) Context {
	return context.WithValue(parent, key, val)
}

// WithoutCancel returns a copy of parent that is not canceled when parent is canceled.
// The returned context returns no Deadline or Err, and its Done channel is nil.
// Calling [Cause] on the returned context returns nil.
func WithoutCancel(parent Context) Context {
	return context.WithoutCancel(parent)
}
